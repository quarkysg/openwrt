--- linux-openwrt/include/linux/watchdog.h	2019-01-04 07:30:51.223590898 +0800
+++ linux-msm/include/linux/watchdog.h	2019-01-04 08:11:53.001467399 +0800
@@ -29,6 +29,8 @@
  * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).
  * @get_timeleft:The routine that gets the time left before a reset (in seconds).
  * @restart:	The routine for restarting the machine.
+ * @ref:	The ref operation for dyn. allocated watchdog_device structs
+ * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
  *
  * The watchdog_ops structure contains a list of low-level operations
@@ -47,12 +47,16 @@
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
 	int (*restart)(struct watchdog_device *, unsigned long, void *);
+	void (*ref)(struct watchdog_device *);
+	void (*unref)(struct watchdog_device *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 
 /** struct watchdog_device - The structure that defines a watchdog device
  *
  * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
+ * @cdev:	The watchdog's Character device.
+ * @dev:	The device for our watchdog
  * @parent:	The parent bus device
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
@@ -64,6 +64,8 @@
  * @restart_nb:	The notifier block to register a restart function.
  * @driver_data:Pointer to the drivers private data.
  * @wd_data:	Pointer to watchdog core internal data.
+ * @driver-data:Pointer to the drivers private data.
+ * @lock:	Lock for watchdog core internal use only.
  * @status:	Field that contains the devices internal status bits.
  * @deferred: entry in wtd_deferred_reg_list which is used to
  *			   register early initialized watchdogs.
@@ -79,6 +79,8 @@
  */
 struct watchdog_device {
 	int id;
+	struct cdev cdev;
+	struct device *dev;
 	struct device *parent;
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
@@ -90,11 +90,15 @@
 	struct notifier_block restart_nb;
 	void *driver_data;
 	struct watchdog_core_data *wd_data;
+	struct mutex lock;
 	unsigned long status;
 /* Bit numbers for status flags */
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
 #define WDOG_NO_WAY_OUT		1	/* Is 'nowayout' feature set ? */
 #define WDOG_STOP_ON_REBOOT	2	/* Should be stopped on reboot */
+#define WDOG_DEV_OPEN		3	/* Opened via /dev/watchdog ? */
+#define WDOG_ALLOW_RELEASE	4	/* Did we receive the magic char ? */
+#define WDOG_UNREGISTERED	5	/* Has the device been unregistered */
 	struct list_head deferred;
 };
 
--- a/drivers/watchdog/qcom-wdt.c	2019-01-04 07:30:51.231590898 +0800
+++ b/drivers/watchdog/qcom-wdt.c	2019-01-04 08:11:48.446467399 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014,2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -16,14 +16,22 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/reboot.h>
 #include <linux/watchdog.h>
-#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/qcom_scm.h>
+#include <linux/smp.h>
+#include <linux/utsname.h>
+#include <linux/sizes.h>
+
+static int in_panic;
 
 enum wdt_reg {
 	WDT_RST,
 	WDT_EN,
-	WDT_STS,
 	WDT_BARK_TIME,
 	WDT_BITE_TIME,
 };
@@ -31,7 +39,6 @@
 static const u32 reg_offset_data_apcs_tmr[] = {
 	[WDT_RST] = 0x38,
 	[WDT_EN] = 0x40,
-	[WDT_STS] = 0x44,
 	[WDT_BARK_TIME] = 0x4C,
 	[WDT_BITE_TIME] = 0x5C,
 };
@@ -39,22 +46,91 @@
 static const u32 reg_offset_data_kpss[] = {
 	[WDT_RST] = 0x4,
 	[WDT_EN] = 0x8,
-	[WDT_STS] = 0xC,
 	[WDT_BARK_TIME] = 0x10,
 	[WDT_BITE_TIME] = 0x14,
 };
 
+struct qcom_wdt_props {
+	const u32 *layout;
+	unsigned int tlv_msg_offset;
+	unsigned int crashdump_page_size;
+};
+
 struct qcom_wdt {
 	struct watchdog_device	wdd;
 	struct clk		*clk;
 	unsigned long		rate;
+	unsigned int		bite;
+	struct notifier_block	restart_nb;
 	void __iomem		*base;
-	const u32		*layout;
+	const struct qcom_wdt_props *dev_props;
+	struct resource *tlv_res;
+};
+
+struct qcom_wdt_scm_tlv_msg {
+	unsigned char *msg_buffer;
+	unsigned char *cur_msg_buffer_pos;
+	unsigned int len;
+};
+
+#define QCOM_WDT_SCM_TLV_TYPE_SIZE	1
+#define QCOM_WDT_SCM_TLV_LEN_SIZE	2
+#define QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE	(QCOM_WDT_SCM_TLV_TYPE_SIZE +\
+						QCOM_WDT_SCM_TLV_LEN_SIZE)
+enum {
+	QCOM_WDT_LOG_DUMP_TYPE_INVALID,
+	QCOM_WDT_LOG_DUMP_TYPE_UNAME,
 };
 
 static void __iomem *wdt_addr(struct qcom_wdt *wdt, enum wdt_reg reg)
 {
-	return wdt->base + wdt->layout[reg];
+	return wdt->base + wdt->dev_props->layout[reg];
+};
+
+static int qcom_wdt_scm_add_tlv(struct qcom_wdt_scm_tlv_msg *scm_tlv_msg,
+			unsigned char type, unsigned int size, const char *data)
+{
+	unsigned char *x = scm_tlv_msg->cur_msg_buffer_pos;
+	unsigned char *y = scm_tlv_msg->msg_buffer + scm_tlv_msg->len;
+
+	if ((x + QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE + size) >= y)
+		return -ENOBUFS;
+
+	x[0] = type;
+	x[1] = size;
+	x[2] = size >> 8;
+
+	memcpy(x + 3, data, size);
+
+	scm_tlv_msg->cur_msg_buffer_pos +=
+		(size + QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE);
+
+	return 0;
+}
+
+static int qcom_wdt_scm_fill_log_dump_tlv(
+			struct qcom_wdt_scm_tlv_msg *scm_tlv_msg)
+{
+	struct new_utsname *uname;
+	int ret_val;
+
+	uname = utsname();
+
+	ret_val = qcom_wdt_scm_add_tlv(scm_tlv_msg,
+			QCOM_WDT_LOG_DUMP_TYPE_UNAME,
+			sizeof(*uname),
+			(unsigned char *)uname);
+
+	if (ret_val)
+		return ret_val;
+
+	if (scm_tlv_msg->cur_msg_buffer_pos >=
+		scm_tlv_msg->msg_buffer + scm_tlv_msg->len)
+		return -ENOBUFS;
+
+	*scm_tlv_msg->cur_msg_buffer_pos++ = QCOM_WDT_LOG_DUMP_TYPE_INVALID;
+
+	return 0;
 }
 
 static inline
@@ -63,14 +139,113 @@
 	return container_of(wdd, struct qcom_wdt, wdd);
 }
 
-static int qcom_wdt_start(struct watchdog_device *wdd)
+static int panic_prep_restart(struct notifier_block *this,
+				unsigned long event, void *ptr)
+{
+	in_panic = 1;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_blk = {
+	.notifier_call  = panic_prep_restart,
+};
+
+static long qcom_wdt_configure_bark_dump(void *arg)
+{
+	void *scm_regsave;
+	struct qcom_wdt_scm_tlv_msg tlv_msg;
+	void *tlv_ptr;
+	resource_size_t tlv_base;
+	resource_size_t tlv_size;
+	struct qcom_wdt *wdt = (struct qcom_wdt *) arg;
+	const struct qcom_wdt_props *device_props = wdt->dev_props;
+	long ret = -ENOMEM;
+	struct resource *res = wdt->tlv_res;
+
+	scm_regsave = (void *) __get_free_pages(GFP_KERNEL,
+				get_order(device_props->crashdump_page_size));
+	if (!scm_regsave)
+		return -ENOMEM;
+
+	ret = qcom_scm_regsave(SCM_SVC_UTIL, SCM_CMD_SET_REGSAVE,
+			scm_regsave, device_props->crashdump_page_size);
+	if (ret) {
+		pr_err("Setting register save address failed.\n"
+			"Registers won't be dumped on a dog bite\n");
+		return ret;
+	}
+
+	/* Initialize the tlv and fill all the details */
+	tlv_msg.msg_buffer = scm_regsave + device_props->tlv_msg_offset;
+	tlv_msg.cur_msg_buffer_pos = tlv_msg.msg_buffer;
+	tlv_msg.len = device_props->crashdump_page_size -
+				 device_props->tlv_msg_offset;
+
+	ret = qcom_wdt_scm_fill_log_dump_tlv(&tlv_msg);
+
+	/* if failed, we still return 0 because it should not
+	 * affect the boot flow. The return value 0 does not
+	 * necessarily indicate success in this function.
+	 */
+	if (ret) {
+		pr_err("log dump initialization failed\n");
+		return 0;
+	}
+
+	if (res) {
+		tlv_base = res->start;
+		tlv_size = resource_size(res);
+		res = request_mem_region(tlv_base, tlv_size, "tlv_dump");
+
+		if (!res) {
+			pr_err("requesting memory region failed\n");
+			return 0;
+		}
+
+		tlv_ptr = ioremap(tlv_base, tlv_size);
+
+		if (!tlv_ptr) {
+			pr_err("mapping physical mem failed\n");
+			release_mem_region(tlv_base, tlv_size);
+			return 0;
+		}
+
+		memcpy_toio(tlv_ptr, tlv_msg.msg_buffer, tlv_msg.len);
+		iounmap(tlv_ptr);
+		release_mem_region(tlv_base, tlv_size);
+	}
+
+	return 0;
+}
+
+static int qcom_wdt_start_secure(struct watchdog_device *wdd)
+{
+	struct qcom_wdt *wdt = to_qcom_wdt(wdd);
+
+	writel(0, wdt_addr(wdt, WDT_EN));
+	writel(1, wdt_addr(wdt, WDT_RST));
+
+	if (wdt->bite) {
+		writel((wdd->timeout - 1) * wdt->rate,
+			wdt_addr(wdt, WDT_BARK_TIME));
+		writel(wdd->timeout * wdt->rate, wdt_addr(wdt, WDT_BITE_TIME));
+	} else {
+		writel(wdd->timeout * wdt->rate, wdt_addr(wdt, WDT_BARK_TIME));
+		writel((wdd->timeout * wdt->rate) * 2, wdt_addr(wdt, WDT_BITE_TIME));
+	}
+
+	writel(1, wdt_addr(wdt, WDT_EN));
+	return 0;
+}
+
+static int qcom_wdt_start_nonsecure(struct watchdog_device *wdd)
 {
 	struct qcom_wdt *wdt = to_qcom_wdt(wdd);
 
 	writel(0, wdt_addr(wdt, WDT_EN));
 	writel(1, wdt_addr(wdt, WDT_RST));
 	writel(wdd->timeout * wdt->rate, wdt_addr(wdt, WDT_BARK_TIME));
-	writel(wdd->timeout * wdt->rate, wdt_addr(wdt, WDT_BITE_TIME));
+	writel(0x0FFFFFFF, wdt_addr(wdt, WDT_BITE_TIME));
 	writel(1, wdt_addr(wdt, WDT_EN));
 	return 0;
 }
@@ -95,13 +270,77 @@
 				unsigned int timeout)
 {
 	wdd->timeout = timeout;
-	return qcom_wdt_start(wdd);
+	return wdd->ops->start(wdd);
 }
 
-static int qcom_wdt_restart(struct watchdog_device *wdd, unsigned long action,
+static const struct watchdog_ops qcom_wdt_ops_secure = {
+	.start		= qcom_wdt_start_secure,
+	.stop		= qcom_wdt_stop,
+	.ping		= qcom_wdt_ping,
+	.set_timeout	= qcom_wdt_set_timeout,
+	.owner		= THIS_MODULE,
+};
+
+static const struct watchdog_ops qcom_wdt_ops_nonsecure = {
+	.start		= qcom_wdt_start_nonsecure,
+	.stop		= qcom_wdt_stop,
+	.ping		= qcom_wdt_ping,
+	.set_timeout	= qcom_wdt_set_timeout,
+	.owner		= THIS_MODULE,
+};
+
+static const struct watchdog_info qcom_wdt_info = {
+	.options	= WDIOF_KEEPALIVEPING
+			| WDIOF_MAGICCLOSE
+			| WDIOF_SETTIMEOUT,
+	.identity	= KBUILD_MODNAME,
+};
+
+const struct qcom_wdt_props qcom_wdt_props_ipq8064 = {
+	.layout = reg_offset_data_apcs_tmr,
+	.tlv_msg_offset = SZ_2K,
+	.crashdump_page_size = SZ_4K,
+};
+
+const struct qcom_wdt_props qcom_wdt_props_ipq807x = {
+	.layout = reg_offset_data_kpss,
+	.tlv_msg_offset = SZ_4K,
+	/* As SBL overwrites the NSS IMEM, TZ has to copy it to some memory
+	 * on crash before it restarts the system. Hence, reserving of 384K
+	 * is required to copy the NSS IMEM before restart is done.
+	 * So that TZ can dump NSS dump data after the first 8K.
+	 * Additionally 8K memory is allocated which can be used by TZ
+	 * to dump PMIC memory.
+	 * get_order function returns the next higher order as output,
+	 * so when we pass 400K as argument 512K will be allocated.
+	 * 112K is unused currently and can be used based on future needs.
+	 */
+	.crashdump_page_size = (SZ_8K + (384 * SZ_1K) + (SZ_8K)),
+};
+
+const struct qcom_wdt_props qcom_wdt_props_ipq40xx = {
+	.layout = reg_offset_data_kpss,
+	.tlv_msg_offset = SZ_2K,
+	.crashdump_page_size = SZ_4K,
+};
+
+static const struct of_device_id qcom_wdt_of_table[] = {
+	{	.compatible = "qcom,kpss-wdt-ipq8064",
+		.data = (void *) &qcom_wdt_props_ipq8064,
+	},
+	{	.compatible = "qcom,kpss-wdt-ipq807x",
+		.data = (void *) &qcom_wdt_props_ipq807x,
+	},
+	{	.compatible = "qcom,kpss-wdt-ipq40xx",
+		.data = (void *) &qcom_wdt_props_ipq40xx,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, qcom_wdt_of_table);
+static int qcom_wdt_restart(struct notifier_block *nb, unsigned long action,
 			    void *data)
 {
-	struct qcom_wdt *wdt = to_qcom_wdt(wdd);
+	struct qcom_wdt *wdt = container_of(nb, struct qcom_wdt, restart_nb);
 	u32 timeout;
 
 	/*
@@ -112,56 +351,80 @@
 
 	writel(0, wdt_addr(wdt, WDT_EN));
 	writel(1, wdt_addr(wdt, WDT_RST));
-	writel(timeout, wdt_addr(wdt, WDT_BARK_TIME));
-	writel(timeout, wdt_addr(wdt, WDT_BITE_TIME));
-	writel(1, wdt_addr(wdt, WDT_EN));
+	if (in_panic) {
+		writel(timeout, wdt_addr(wdt, WDT_BARK_TIME));
+		writel(2 * timeout, wdt_addr(wdt, WDT_BITE_TIME));
+	} else {
+		writel(5 * timeout, wdt_addr(wdt, WDT_BARK_TIME));
+		writel(timeout, wdt_addr(wdt, WDT_BITE_TIME));
+	}
 
+	writel(1, wdt_addr(wdt, WDT_EN));
 	/*
 	 * Actually make sure the above sequence hits hardware before sleeping.
 	 */
 	wmb();
 
-	msleep(150);
-	return 0;
+	mdelay(150);
+	return NOTIFY_DONE;
 }
 
-static const struct watchdog_ops qcom_wdt_ops = {
-	.start		= qcom_wdt_start,
-	.stop		= qcom_wdt_stop,
-	.ping		= qcom_wdt_ping,
-	.set_timeout	= qcom_wdt_set_timeout,
-	.restart        = qcom_wdt_restart,
-	.owner		= THIS_MODULE,
-};
+static irqreturn_t wdt_bark_isr(int irq, void *wdd)
+{
+	struct qcom_wdt *wdt = to_qcom_wdt(wdd);
+	unsigned long nanosec_rem;
+	unsigned long long t = sched_clock();
 
-static const struct watchdog_info qcom_wdt_info = {
-	.options	= WDIOF_KEEPALIVEPING
-			| WDIOF_MAGICCLOSE
-			| WDIOF_SETTIMEOUT
-			| WDIOF_CARDRESET,
-	.identity	= KBUILD_MODNAME,
-};
+	nanosec_rem = do_div(t, 1000000000);
+	pr_info("Watchdog bark! Now = %lu.%06lu\n", (unsigned long) t,
+							nanosec_rem / 1000);
+	pr_info("Causing a watchdog bite!");
+	writel(0, wdt_addr(wdt, WDT_EN));
+	writel(1, wdt_addr(wdt, WDT_BITE_TIME));
+	mb(); /* Avoid unpredictable behaviour in concurrent executions */
+	pr_info("Configuring Watchdog Timer\n");
+	writel(1, wdt_addr(wdt, WDT_RST));
+	writel(1, wdt_addr(wdt, WDT_EN));
+	mb(); /* Make sure the above sequence hits hardware before Reboot. */
+	pr_info("Waiting for Reboot\n");
+
+	mdelay(1);
+	pr_err("Wdog - CTL: 0x%x, BARK TIME: 0x%x, BITE TIME: 0x%x",
+		readl(wdt_addr(wdt, WDT_EN)),
+		readl(wdt_addr(wdt, WDT_BARK_TIME)),
+		readl(wdt_addr(wdt, WDT_BITE_TIME)));
+	return IRQ_HANDLED;
+}
+
+void register_wdt_bark_irq(int irq, struct qcom_wdt *wdt)
+{
+	int ret;
+
+	ret = request_irq(irq, wdt_bark_isr, IRQF_TRIGGER_HIGH,
+						"watchdog bark", wdt);
+	if (ret)
+		pr_err("error request_irq(irq_num:%d ) ret:%d\n", irq, ret);
+}
 
 static int qcom_wdt_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *id;
 	struct qcom_wdt *wdt;
 	struct resource *res;
 	struct device_node *np = pdev->dev.of_node;
-	const u32 *regs;
 	u32 percpu_offset;
-	int ret;
-
-	regs = of_device_get_match_data(&pdev->dev);
-	if (!regs) {
-		dev_err(&pdev->dev, "Unsupported QCOM WDT module\n");
-		return -ENODEV;
-	}
+	int ret, irq;
+	uint32_t val;
 
 	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
 	if (!wdt)
 		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq_byname(pdev, "bark_irq");
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "kpss_wdt");
+	if (!res) {
+		dev_err(&pdev->dev, "%s: no mem resource\n", __func__);
+		return -EINVAL;
+	}
 
 	/* We use CPU0's DGT for the watchdog */
 	if (of_property_read_u32(np, "cpu-offset", &percpu_offset))
@@ -174,6 +437,21 @@
 	if (IS_ERR(wdt->base))
 		return PTR_ERR(wdt->base);
 
+	wdt->tlv_res = platform_get_resource_byname
+			(pdev, IORESOURCE_MEM, "tlv");
+
+	id = of_match_device(qcom_wdt_of_table, &pdev->dev);
+	if (!id)
+		return -ENODEV;
+
+	wdt->dev_props = (struct qcom_wdt_props *)id->data;
+
+	if (wdt->dev_props->layout)
+		wdt->bite = 1;
+
+	if (irq > 0)
+		register_wdt_bark_irq(irq, wdt);
+
 	wdt->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(wdt->clk)) {
 		dev_err(&pdev->dev, "failed to get input clock\n");
@@ -202,15 +480,20 @@
 		goto err_clk_unprepare;
 	}
 
+	ret = work_on_cpu(0, qcom_wdt_configure_bark_dump, wdt);
+	if (ret)
+		wdt->wdd.ops = &qcom_wdt_ops_nonsecure;
+	else
+		wdt->wdd.ops = &qcom_wdt_ops_secure;
+
+	wdt->wdd.dev = &pdev->dev;
 	wdt->wdd.info = &qcom_wdt_info;
-	wdt->wdd.ops = &qcom_wdt_ops;
 	wdt->wdd.min_timeout = 1;
-	wdt->wdd.max_timeout = 0x10000000U / wdt->rate;
+	if (!of_property_read_u32(np, "wdt-max-timeout", &val))
+		wdt->wdd.max_timeout = val;
+	else
+		wdt->wdd.max_timeout = 0x10000000U / wdt->rate;
 	wdt->wdd.parent = &pdev->dev;
-	wdt->layout = regs;
-
-	if (readl(wdt->base + WDT_STS) & 1)
-		wdt->wdd.bootstatus = WDIOF_CARDRESET;
 
 	/*
 	 * If 'timeout-sec' unspecified in devicetree, assume a 30 second
@@ -226,6 +509,15 @@
 		goto err_clk_unprepare;
 	}
 
+	/*
+	 * WDT restart notifier has priority 0 (use as a last resort)
+	 */
+	wdt->restart_nb.notifier_call = qcom_wdt_restart;
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+	ret = register_restart_handler(&wdt->restart_nb);
+	if (ret)
+		dev_err(&pdev->dev, "failed to setup restart handler\n");
+
 	platform_set_drvdata(pdev, wdt);
 	return 0;
 
@@ -238,19 +530,12 @@
 {
 	struct qcom_wdt *wdt = platform_get_drvdata(pdev);
 
+	unregister_restart_handler(&wdt->restart_nb);
 	watchdog_unregister_device(&wdt->wdd);
 	clk_disable_unprepare(wdt->clk);
 	return 0;
 }
 
-static const struct of_device_id qcom_wdt_of_table[] = {
-	{ .compatible = "qcom,kpss-timer", .data = reg_offset_data_apcs_tmr },
-	{ .compatible = "qcom,scss-timer", .data = reg_offset_data_apcs_tmr },
-	{ .compatible = "qcom,kpss-wdt", .data = reg_offset_data_kpss },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, qcom_wdt_of_table);
-
 static struct platform_driver qcom_watchdog_driver = {
 	.probe	= qcom_wdt_probe,
 	.remove	= qcom_wdt_remove,
