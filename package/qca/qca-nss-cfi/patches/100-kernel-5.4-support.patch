--- a/cryptoapi/v1.1/nss_cryptoapi.c
+++ b/cryptoapi/v1.1/nss_cryptoapi.c
@@ -231,7 +231,6 @@ static struct crypto_alg cryptoapi_ablkc
 		.cra_u          = {
 			.ablkcipher = {
 				.ivsize         = CTR_RFC3686_IV_SIZE,
-				.geniv          = "seqiv",
 				.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
 				.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
 				.setkey         = nss_cryptoapi_ablk_aes_setkey,
--- a/cryptoapi/v1.1/nss_cryptoapi_ablk.c
+++ b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
@@ -108,7 +108,7 @@ EXPORT_SYMBOL(nss_cryptoapi_skcipher_ctx
 int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
 {
 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
-	struct crypto_ablkcipher *sw_tfm;
+	struct crypto_cipher *sw_tfm;
 
 	nss_cfi_assert(ctx);
 
@@ -126,7 +126,7 @@ int nss_cryptoapi_ablkcipher_init(struct
 		return 0;
 
 	/* Alloc fallback transform for future use */
-	sw_tfm = crypto_alloc_ablkcipher(crypto_tfm_alg_name(tfm), 0, CRYPTO_ALG_ASYNC |
+	sw_tfm = crypto_alloc_cipher(crypto_tfm_alg_name(tfm), 0, CRYPTO_ALG_ASYNC |
 									CRYPTO_ALG_NEED_FALLBACK);
 	if (IS_ERR(sw_tfm)) {
 		nss_cfi_err("unable to alloc software crypto for %s\n", crypto_tfm_alg_name(tfm));
@@ -134,8 +134,7 @@ int nss_cryptoapi_ablkcipher_init(struct
 	}
 
 	/* set this tfm reqsize same to fallback tfm */
-	tfm->crt_ablkcipher.reqsize = crypto_ablkcipher_reqsize(sw_tfm);
-	ctx->sw_tfm = crypto_ablkcipher_tfm(sw_tfm);
+	ctx->sw_tfm = crypto_cipher_tfm(sw_tfm);
 
 	return 0;
 }
--- a/Makefile
+++ b/Makefile
@@ -4,9 +4,4 @@
 
 export BUILD_ID = \"Build Id: $(shell date +'%m/%d/%y, %H:%M:%S')\"
 
-obj-m += $(CFI_OCF_DIR)/
 obj-m += $(CFI_CRYPTOAPI_DIR)/
-
-ifeq ($(SoC),$(filter $(SoC),ipq806x))
-obj-m += $(CFI_IPSEC_DIR)/
-endif
